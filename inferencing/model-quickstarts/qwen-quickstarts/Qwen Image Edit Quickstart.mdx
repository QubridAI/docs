> Get started with Qwen Image Edit, a specialized model engineered for  
> Precision Image Manipulation and Creative Editing.

The **Qwen-Image-Edit** is a cutting-edge vision-language model designed to modify existing images based on natural language instructions. Unlike standard generation models that create images from scratch, this model understands the content of an input image and applies specific edits—such as adding objects, changing backgrounds, or altering styles—while preserving the original structure and context.

This model excels at understanding complex editing requests, maintaining visual consistency, and delivering high-quality results for both realistic and artistic modifications.

<Frame>
  <img src="/images/qwen-image-edit-abhiiiman.png" />
</Frame>

## Using Qwen Image Edit Inference API

This model is accessible to users on Build Tier 1 or higher. The API accepts an input image file along with text prompts to guide the editing process.

<CodeGroup>
  ```python Python theme={null}
import requests

url = "https://platform.qubrid.com/api/v1/qubridai/image/edit"
headers = {
    "Authorization": "Bearer Qubrid_API_KEY"
}

# Prepare the file and data

files = {
    'image': ('input.png', open('input.png', 'rb'), 'image/png')
}
data = {
    "model": "Qwen/Qwen-Image-Edit",
    "prompt": "Add a rainbow in the sky",
    "negative_prompt": "blur, low quality, distortion",
    "true_cfg_scale": 4,
    "num_inference_steps": 40,
    "seed": 42,
    "use_inpainting": "false"
}

response = requests.post(url, headers=headers, files=files, data=data)

# Save the result

result = response.json()
print(result)
````

```js JavaScript theme={null}
const formData = new FormData();
formData.append("model", "Qwen/Qwen-Image-Edit");
formData.append("prompt", "Add a rainbow in the sky");
formData.append("negative_prompt", "blur, low quality, distortion");
formData.append("true_cfg_scale", "4");
formData.append("num_inference_steps", "40");
formData.append("seed", "42");
formData.append("use_inpainting", "false");

// Assuming you have a file input or blob
const fileInput = document.querySelector('input[type="file"]');
formData.append("image", fileInput.files[0]);

const res = await fetch("https://platform.qubrid.com/api/v1/qubridai/image/edit", {
  method: "POST",
  headers: {
    Authorization: "Bearer Qubrid_API_KEY"
    // Content-Type is automatically set with boundary for FormData
  },
  body: formData
});

const result = await res.json();
console.log(result);
````

```go Go theme={null}
package main

import (
	"bytes"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
)

func main() {
	url := "https://platform.qubrid.com/api/v1/qubridai/image/edit"
	method := "POST"

	payload := &bytes.Buffer{}
	writer := multipart.NewWriter(payload)

    // Add fields
	_ = writer.WriteField("model", "Qwen/Qwen-Image-Edit")
	_ = writer.WriteField("prompt", "Add a rainbow in the sky")
	_ = writer.WriteField("negative_prompt", "blur, low quality")
	_ = writer.WriteField("true_cfg_scale", "4")
	_ = writer.WriteField("num_inference_steps", "40")
	_ = writer.WriteField("seed", "42")
	_ = writer.WriteField("use_inpainting", "false")

    // Add file
	file, _ := os.Open("input.png")
	defer file.Close()
	part, _ := writer.CreateFormFile("image", filepath.Base(file.Name()))
	io.Copy(part, file)

	writer.Close()

	client := &http.Client{}
	req, _ := http.NewRequest(method, url, payload)

	req.Header.Add("Authorization", "Bearer Qubrid_API_KEY")
	req.Header.Set("Content-Type", writer.FormDataContentType())

	res, _ := client.Do(req)
	defer res.Body.Close()

	body, _ := io.ReadAll(res.Body)
	fmt.Println(string(body))
}
```

```curl cURL theme={null}
curl -X POST "https://platform.qubrid.com/api/v1/qubridai/image/edit" \
  -H "Authorization: Bearer Qubrid_API_KEY" \
  -F "model=Qwen/Qwen-Image-Edit" \
  -F "prompt=Add a rainbow in the sky" \
  -F "negative_prompt=" \
  -F "true_cfg_scale=4" \
  -F "num_inference_steps=40" \
  -F "seed=42" \
  -F "use_inpainting=false" \
  -F "image=@input.png" \
  -o edited_output.json
```

</CodeGroup>

This will produce a JSON response containing the URL or data of the edited image:

```json theme={null}
{
  "created": 1764851500,
  "data": [
    {
      "url": "https://qubrid-storage.s3.amazonaws.com/generated/edited-image-xyz.png"
    }
  ]
}
```

## Available Models

The Qwen Image Edit model is optimized for instruction-following image manipulation:

**Qwen-Image-Edit**

- **Model String**: `Qwen/Qwen-Image-Edit`
- **Input Type**: Image (PNG/JPG) + Text Prompt
- **Capabilities**: Object addition/removal, background replacement, style transfer, color correction
- **Best for**: Creative design, photo retouching, e-commerce asset generation

## Qwen Image Edit Best Practices

To achieve the best results with Qwen Image Edit, consider these parameters and prompting strategies:

**Recommended Parameters**

- **Prompt**: Be descriptive about the change you want. Instead of just "rainbow", use "Add a bright rainbow arching over the mountains in the background".
- **True CFG Scale**: Controls how strictly the model follows the text prompt.
  - **Low (1-3)**: More creative freedom, less adherence to prompt.
  - **Medium (4-7)**: Balanced (Recommended).
  - **High (8+)**: Strict adherence, potentially less natural blending.
- **Num Inference Steps**: Higher steps (e.g., 40-50) generally yield higher quality details but take longer to process.
- **Negative Prompt**: Specify what you want to avoid (e.g., "blur, distortion, low resolution, extra fingers").
- **Use Inpainting**: Set to `true` if you are providing a mask or want the model to infer a mask for specific area editing.

**Prompting Best Practices**

- **Focus on the Edit**: The prompt should describe the _result_ you want to see or the _action_ to perform.
- **Preserve Context**: If you want to keep the rest of the image unchanged, ensure your prompt doesn't contradict the existing scene unless intended.
- **Iterative Editing**: For complex changes, it is often better to perform one edit at a time (e.g., change background first, then add an object).

## Qwen Image Edit Use Cases

- **E-commerce**: Change product backgrounds or add lifestyle elements to product shots.
- **Real Estate**: Virtual staging, changing sky conditions (day to dusk), or removing clutter.
- **Creative Design**: Rapidly prototyping variations of a design concept.
- **Photo Retouching**: Removing unwanted objects or people from photographs.
- **Marketing**: Adapting a single visual asset for different campaigns or seasonal themes.

## Managing Context and Costs

#### **Image Optimization**

- **Input Resolution**: Ensure input images are of reasonable resolution. Extremely high-resolution images may be resized or incur higher latency.
- **File Size**: Compress images (e.g., standard JPEG/PNG) before uploading to reduce network transfer time.

#### **Cost Optimization**

- **Step Count**: Lower `num_inference_steps` for draft iterations to save on compute time, then increase for the final render.
- **Batching**: If editing multiple images with similar prompts, ensure your workflow handles them efficiently, though the API processes one request at a time.

## Technical Architecture

#### **Model Architecture**

- **Foundation**: Built on advanced diffusion transformer architectures fine-tuned for instruction-based image editing.
- **Vision-Language Alignment**: Uses a powerful vision encoder to understand the input image semantics and aligns them with the text prompt to guide the diffusion process.
- **Precision**: Designed to minimize artifacts and "hallucinations" in the unedited parts of the image, ensuring high fidelity to the original source where changes are not requested.
