---
title: "Qwen3 Coder 30B A3B (Qwen)"
description: "> A high-performance coding and reasoning model designed for long-context code generation and technical workflows."
---

<Frame>
  <img src="/images/qwen-coder-abhiiiman.png" />
</Frame>

## Model Quickstart

This section helps you quickly get started with the `Qwen3 Coder 30B A3B` model on the Qubrid AI inferencing platform.

To use this model, you need:

- A valid **Qubrid API key**
- Access to the Qubrid inference API
- Basic knowledge of making API requests in your preferred language

Once authenticated with your API key, you can send inference requests to the `Qwen3 Coder 30B A3B ` model and receive responses based on your input prompts.

Below are example placeholders showing how the model can be accessed using different programming environments.  
You can choose the one that best fits your workflow.

<CodeGroup>
  ```python Python theme={null}
import requests
import json
from pprint import pprint

url = "https://platform.qubrid.com/api/v1/qubridai/chat/completions"
headers = {
  "Authorization": "Bearer <Qubrid_API_KEY>",
  "Content-Type": "application/json"
}

data = {
  "model": "Qwen/Qwen3-Coder-30B-A3B-Instruct",
  "messages": [
    {
      "role": "user",
      "content": "Write a Python function to calculate fibonacci sequence"
    }
  ],
  "temperature": 0.7,
  "max_tokens": 4096,
  "stream": False
}
response = requests.post(
    url,
    headers=headers,
    json=data, 
)
content_type = response.headers.get("Content-Type", "")
if "application/json" in content_type:
    pprint(response.json())
else:
    for line in response.iter_lines(decode_unicode=True):
        if not line:
            continue

        if line.startswith("data:"):
            payload = line.replace("data:", "").strip()

            if payload == "[DONE]":
                break
            try:
                chunk = json.loads(payload)
                pprint(chunk)
            except json.JSONDecodeError:
                print("Raw chunk:", payload)
````

```js JavaScript theme={null}
(async () => {
  const body = {
    model: "Qwen/Qwen3-Coder-30B-A3B-Instruct",
    messages: [
      {
        role: "system",
        content:
          "You are an expert software engineer. Write clean, efficient, and well-documented code.",
      },
      {
        role: "user",
        content:
          "Write a Python function to calculate the Fibonacci sequence using dynamic programming.",
      },
    ],
    temperature: 0.2,
    max_tokens: 4096,
    stream: false,
    top_p: 0.95,
  };

  const res = await fetch(
    "https://platform.qubrid.com/api/v1/qubridai/chat/completions",
    {
      method: "POST",
      headers: {
        Authorization:
          "Bearer <QUBRID_API_KEY>",
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    }
  );

  const contentType = res.headers.get("content-type") || "";
  if (contentType.includes("application/json")) {
    const result = await res.json();
    console.log(result);
  } else {
    const reader = res.body.getReader();
    const decoder = new TextDecoder("utf-8");
    let buffer = "";
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop();
      for (const line of lines) {
        if (!line.startsWith("data:")) continue;
        const payload = line.replace("data:", "").trim();
        if (payload === "[DONE]") return;
        try {
          const chunk = JSON.parse(payload);
          console.log(chunk);
        } catch {
          console.log("Raw chunk:", payload);
        }
      }
    }
  }
})();
````

```go Go theme={null}
package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
)

func main() {
  url := "https://platform.qubrid.com/api/v1/qubridai/chat/completions"

  data := map[string]interface{}{
    "model": "Qwen/Qwen3-Coder-30B-A3B-Instruct",
    "messages": []map[string]string{
      {
        "role": "system",
        "content": "You are an expert software engineer. Write clean, efficient, and well-documented code.",
      },
      {
        "role": "user",
        "content": "Write a Python function to calculate the Fibonacci sequence using dynamic programming.",
      },
    },
    "temperature": 0.2,
    "max_tokens": 4096,
    "stream": false,
    "top_p": 0.95,
  }
  jsonData, err := json.Marshal(data)
    if err != nil {
		panic(err)
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		panic(err)
	}

	req.Header.Set("Authorization", "Bearer <QUBRID_API_KEY>")
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	res, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer res.Body.Close()
	contentType := res.Header.Get("Content-Type")
	if strings.Contains(contentType, "application/json") {
		var result map[string]interface{}
		if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
			panic(err)
		}
		fmt.Printf("%+v\n", result)
		return
	}
	scanner := bufio.NewScanner(res.Body)
	for scanner.Scan() {
		line := scanner.Text()
		if !strings.HasPrefix(line, "data:") {
			continue
		}
		payload := strings.TrimSpace(strings.TrimPrefix(line, "data:"))
		if payload == "[DONE]" {
			break
		}
		var chunk map[string]interface{}
		if err := json.Unmarshal([]byte(payload), &chunk); err != nil {
			fmt.Println("Raw chunk:", payload)
			continue
		}
		fmt.Printf("%+v\n", chunk)
	}
	if err := scanner.Err(); err != nil {
		panic(err)
	}
}

```

```curl cURL theme={null}
curl -X POST "https://platform.qubrid.com/api/v1/qubridai/chat/completions" \
  -H "Authorization: Bearer Qubrid_API_KEY" \
  -H "Content-Type: application/json" \
  --data '{
  "model": "Qwen/Qwen3-Coder-30B-A3B-Instruct",
  "messages": [
    {
      "role": "system",
      "content": "You are an expert software engineer. Write clean, efficient, and well-documented code."
    },
    {
      "role": "user",
      "content": "Write a Python function to calculate the Fibonacci sequence using dynamic programming."
    }
  ],
  "temperature": 0.2,
  "max_tokens": 4096,
  "stream": false,
  "top_p": 0.95
}'
```

</CodeGroup>

This will produce a response similar to the one below:

````json theme={null}
{
  "id": "chatcmpl-8908cd8b586c496bbef3bba04edbbe99",
  "object": "chat.completion",
  "created": 1764851200,
  "model": "Qwen/Qwen3-Coder-30B-A3B-Instruct",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "Here is a Python function that calculates the Fibonacci sequence using dynamic programming (memoization) for efficiency:\n\n```python\ndef fibonacci_dp(n, memo={}):\n    \"\"\"\n    Calculate the nth Fibonacci number using dynamic programming.\n    \n    Args:\n        n (int): The position in the Fibonacci sequence.\n        memo (dict): Dictionary to store computed values.\n        \n    Returns:\n        int: The nth Fibonacci number.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    \n    memo[n] = fibonacci_dp(n - 1, memo) + fibonacci_dp(n - 2, memo)\n    return memo[n]\n\n# Example usage:\nprint(fibonacci_dp(10))  # Output: 55\n```\n\n### Explanation:\n1. **Memoization**: We use a dictionary `memo` to store previously calculated Fibonacci numbers. This avoids redundant calculations.\n2. **Base Case**: If `n` is 0 or 1, we return `n` directly.\n3. **Recursive Step**: We recursively call the function for `n-1` and `n-2`, storing the result in `memo` before returning it.\n\nThis approach reduces the time complexity from exponential O(2^n) to linear O(n).",
        "refusal": null
      },
      "logprobs": null,
      "finish_reason": "stop",
      "stop_reason": null,
      "token_ids": null
    }
  ],
  "usage": {
    "prompt_tokens": 45,
    "total_tokens": 285,
    "completion_tokens": 240
  }
}
````

## Model Overview

Qwen3 Coder 30B A3B is a large causal language model designed for code generation and technical reasoning. It belongs to the latest generation of the Qwen model family and supports both thinking mode for complex reasoning and non-thinking mode for efficient general usage within the same model.

The model is built using a Mixture-of-Experts (MoE) architecture, activating only a subset of parameters per request to balance performance and efficiency. It is trained through both pretraining and post-training stages and supports long context lengths for complex coding and reasoning workflows.

### Model at a Glance

| Feature                  | Details                                          |
| ------------------------ | ------------------------------------------------ |
| Model ID                 | qwen3-coder-30b-a3b-instruct                     |
| Provider                 | Qwen                                             |
| Model Type               | Causal Language Model                            |
| Architecture             | Mixture-of-Experts (MoE) Transformer, 48 layers, GQA attention, 128 experts (8 active per forward pass)                                                             |
| Model Size               | 1.1B Params                                      |
| Parameters               | 4B                                             |

### When to use?
You should consider using Qwen3 Coder 30B A3B if:

- Your application focuses on code generation or technical reasoning
- You need long context support for large codebases or complex prompts
- You want a model that can switch between deep reasoning and efficient responses
- Your workflow includes agent-based tasks with external tools
- You require multilingual support for technical or coding tasks

### Inference Parameters
| Parameter Name | Type    | Default | Description                                                                 |
|----------------|---------|---------|-----------------------------------------------------------------------------|
| Streaming      | boolean | true    | Enable streaming responses for real-time output.                            |
| Temperature    | number  | 0.7     | Controls randomness; higher values produce more diverse, less deterministic output. |
| Max Tokens     | number  | 65536   | Maximum tokens to generate in the response, suitable for long-form code or large refactors. |
| Top P          | number  | 0.8     | Nucleus sampling controlling token sampling diversity.                      |

### Key Features

- Supports thinking mode for complex reasoning, mathematics, and coding
- Supports non-thinking mode for efficient general-purpose dialogue
- Strong performance in code generation, technical reasoning, and logical tasks
- Designed for agent workflows with tool integration
- Supports multilingual instruction following and translation

## Best Practices

### Sampling Settings

#### Thinking Mode 
(`enable_thinking = true`) :
- **Temperature:** `0.6`  
- **Top-P:** `0.95`  
- **Top-K:** `20`  
- **Min-P:** `0`  
> Avoid greedy decoding to prevent repetition and degraded performance.

#### Non-Thinking Mode 
(`enable_thinking = false`) :
- **Temperature:** `0.7`    
- **Top-P:** `0.8`  
- **Top-K:** `20`  
- **Min-P:** `0`  
---
### Output Length
- **Recommended output length:** `32,768` tokens  
- **For highly complex math or programming problems:** `38,912` tokens  
---
### Prompt Standardization
#### Math Problems
Include the following instruction:
```text
Please reason step by step, and put your final answer within \boxed{}.
```
**Multi-Turn Conversations**
- Historical responses should include only the final output
- Thinking content should not be stored in conversation history
- This behavior is handled automatically in the provided Jinja2 chat template

### Summary
Qwen3 Coder 30B A3B is a 30B parameter Mixture-of-Experts language model. It is optimized for code generation and technical reasoning tasks. The model supports both thinking and non-thinking modes in a single deployment. It provides long context support up to 131K tokens with YaRN. Designed for efficient, multilingual, and agent-based inferencing workflows.
